"""
Boolean expression to compare columns of type "Boolean". All fields are combined with logical 'AND'.
"""
input Boolean_comparison_exp {
  _eq: Boolean

  _gt: Boolean

  _gte: Boolean

  _in: [Boolean!]

  _is_null: Boolean

  _lt: Boolean

  _lte: Boolean

  _neq: Boolean

  _nin: [Boolean!]
}

"""
Boolean expression to compare columns of type "Int". All fields are combined with logical 'AND'.
"""
input Int_comparison_exp {
  _eq: Int

  _gt: Int

  _gte: Int

  _in: [Int!]

  _is_null: Boolean

  _lt: Int

  _lte: Int

  _neq: Int

  _nin: [Int!]
}

"""
Boolean expression to compare columns of type "String". All fields are combined with logical 'AND'.
"""
input String_array_comparison_exp {
  """
  is the array contained in the given array value
  """
  _contained_in: [String!]

  """
  does the array contain the given value
  """
  _contains: [String!]

  _eq: [String!]

  _gt: [String!]

  _gte: [String!]

  _in: [[String!]!]

  _is_null: Boolean

  _lt: [String!]

  _lte: [String!]

  _neq: [String!]

  _nin: [[String!]!]
}

"""
Boolean expression to compare columns of type "String". All fields are combined with logical 'AND'.
"""
input String_comparison_exp {
  _eq: String

  _gt: String

  _gte: String

  """
  does the column match the given case-insensitive pattern
  """
  _ilike: String

  _in: [String!]

  """
  does the column match the given POSIX regular expression, case insensitive
  """
  _iregex: String

  _is_null: Boolean

  """
  does the column match the given pattern
  """
  _like: String

  _lt: String

  _lte: String

  _neq: String

  """
  does the column NOT match the given case-insensitive pattern
  """
  _nilike: String

  _nin: [String!]

  """
  does the column NOT match the given POSIX regular expression, case insensitive
  """
  _niregex: String

  """
  does the column NOT match the given pattern
  """
  _nlike: String

  """
  does the column NOT match the given POSIX regular expression, case sensitive
  """
  _nregex: String

  """
  does the column NOT match the given SQL regular expression
  """
  _nsimilar: String

  """
  does the column match the given POSIX regular expression, case sensitive
  """
  _regex: String

  """
  does the column match the given SQL regular expression
  """
  _similar: String
}

type __Directive {
  args: __InputValue

  description: String!

  isRepeatable: String!

  locations: String!

  name: String!
}

type __EnumValue {
  deprecationReason: String!

  description: String!

  isDeprecated: String!

  name: String!
}

type __Field {
  args: __InputValue

  deprecationReason: String!

  description: String!

  isDeprecated: String!

  name: String!

  type: __Type
}

type __InputValue {
  defaultValue: String!

  description: String!

  name: String!

  type: __Type
}

type __Schema {
  description: String!

  directives: __Directive

  mutationType: __Type

  queryType: __Type

  subscriptionType: __Type

  types: __Type
}

type __Type {
  description: String!

  enumValues(includeDeprecated: Boolean = false): __EnumValue

  fields(includeDeprecated: Boolean = false): __Field

  inputFields: __InputValue

  interfaces: __Type

  kind: __TypeKind!

  name: String!

  ofType: __Type

  possibleTypes: __Type
}

enum __TypeKind {
  ENUM

  INPUT_OBJECT

  INTERFACE

  LIST

  NON_NULL

  OBJECT

  SCALAR

  UNION
}

scalar bigint

"""
Boolean expression to compare columns of type "bigint". All fields are combined with logical 'AND'.
"""
input bigint_comparison_exp {
  _eq: bigint

  _gt: bigint

  _gte: bigint

  _in: [bigint!]

  _is_null: Boolean

  _lt: bigint

  _lte: bigint

  _neq: bigint

  _nin: [bigint!]
}

"""
columns and relationships of "content"
"""
type content {
  created_on: timestamp

  domain: domain

  """
  An object relationship
  """
  git_repo: git_repo

  """
  An array relationship
  """
  git_repos("distinct select on columns" distinct_on: [git_repo_select_column!], "limit the number of rows returned" limit: Int, "skip the first n rows. Use only with order_by" offset: Int, "sort the rows by one or more columns" order_by: [git_repo_order_by!], "filter the rows returned" where: git_repo_bool_exp): [git_repo!]!

  id: String!

  """
  An object relationship
  """
  language: language

  language_id: String

  level: String

  modified_on: timestamp

  name: String!

  namespace: String!

  """
  An array relationship
  """
  rendered_contents("distinct select on columns" distinct_on: [rendered_content_select_column!], "limit the number of rows returned" limit: Int, "skip the first n rows. Use only with order_by" offset: Int, "sort the rows by one or more columns" order_by: [rendered_content_order_by!], "filter the rows returned" where: rendered_content_bool_exp): [rendered_content!]!

  """
  An aggregate relationship
  """
  rendered_contents_aggregate("distinct select on columns" distinct_on: [rendered_content_select_column!], "limit the number of rows returned" limit: Int, "skip the first n rows. Use only with order_by" offset: Int, "sort the rows by one or more columns" order_by: [rendered_content_order_by!], "filter the rows returned" where: rendered_content_bool_exp): rendered_content_aggregate!

  resource_type: String

  title: String

  type: type_id!

  """
  An object relationship
  """
  wa_content_metadata: wa_content_metadata
}

"""
aggregated selection of "content"
"""
type content_aggregate {
  aggregate: content_aggregate_fields

  nodes: [content!]!
}

input content_aggregate_bool_exp {
  count: content_aggregate_bool_exp_count
}

input content_aggregate_bool_exp_count {
  arguments: [content_select_column!]

  distinct: Boolean

  filter: content_bool_exp

  predicate: Int_comparison_exp!
}

"""
aggregate fields of "content"
"""
type content_aggregate_fields {
  count(columns: [content_select_column!], distinct: Boolean): Int!

  max: content_max_fields

  min: content_min_fields
}

"""
order by aggregate values of table "content"
"""
input content_aggregate_order_by {
  count: order_by

  max: content_max_order_by

  min: content_min_order_by
}

"""
Boolean expression to filter rows from the table "content". All fields are combined with a logical 'AND'.
"""
input content_bool_exp {
  _and: [content_bool_exp!]

  _not: content_bool_exp

  _or: [content_bool_exp!]

  created_on: timestamp_comparison_exp

  domain: domain_comparison_exp

  git_repo: git_repo_bool_exp

  git_repos: git_repo_bool_exp

  id: String_comparison_exp

  language: language_bool_exp

  language_id: String_comparison_exp

  level: String_comparison_exp

  modified_on: timestamp_comparison_exp

  name: String_comparison_exp

  namespace: String_comparison_exp

  rendered_contents: rendered_content_bool_exp

  rendered_contents_aggregate: rendered_content_aggregate_bool_exp

  resource_type: String_comparison_exp

  title: String_comparison_exp

  type: type_id_comparison_exp

  wa_content_metadata: wa_content_metadata_bool_exp
}

"""
aggregate max on columns
"""
type content_max_fields {
  created_on: timestamp

  domain: domain

  id: String

  language_id: String

  level: String

  modified_on: timestamp

  name: String

  namespace: String

  resource_type: String

  title: String

  type: type_id
}

"""
order by max() on columns of table "content"
"""
input content_max_order_by {
  created_on: order_by

  domain: order_by

  id: order_by

  language_id: order_by

  level: order_by

  modified_on: order_by

  name: order_by

  namespace: order_by

  resource_type: order_by

  title: order_by

  type: order_by
}

"""
aggregate min on columns
"""
type content_min_fields {
  created_on: timestamp

  domain: domain

  id: String

  language_id: String

  level: String

  modified_on: timestamp

  name: String

  namespace: String

  resource_type: String

  title: String

  type: type_id
}

"""
order by min() on columns of table "content"
"""
input content_min_order_by {
  created_on: order_by

  domain: order_by

  id: order_by

  language_id: order_by

  level: order_by

  modified_on: order_by

  name: order_by

  namespace: order_by

  resource_type: order_by

  title: order_by

  type: order_by
}

"""
Ordering options when selecting data from "content".
"""
input content_order_by {
  created_on: order_by

  domain: order_by

  git_repo: git_repo_order_by

  git_repos_aggregate: git_repo_aggregate_order_by

  id: order_by

  language: language_order_by

  language_id: order_by

  level: order_by

  modified_on: order_by

  name: order_by

  namespace: order_by

  rendered_contents_aggregate: rendered_content_aggregate_order_by

  resource_type: order_by

  title: order_by

  type: order_by

  wa_content_metadata: wa_content_metadata_order_by
}

"""
select columns of table "content"
"""
enum content_select_column {
  """
  column name
  """
  created_on

  """
  column name
  """
  domain

  """
  column name
  """
  id

  """
  column name
  """
  language_id

  """
  column name
  """
  level

  """
  column name
  """
  modified_on

  """
  column name
  """
  name

  """
  column name
  """
  namespace

  """
  column name
  """
  resource_type

  """
  column name
  """
  title

  """
  column name
  """
  type
}

"""
Streaming cursor of the table "content"
"""
input content_stream_cursor_input {
  """
  Stream column input with initial value
  """
  initial_value: content_stream_cursor_value_input!

  """
  cursor ordering
  """
  ordering: cursor_ordering
}

"""
Initial value of the column from where the streaming should start
"""
input content_stream_cursor_value_input {
  created_on: timestamp

  domain: domain

  id: String

  language_id: String

  level: String

  modified_on: timestamp

  name: String

  namespace: String

  resource_type: String

  title: String

  type: type_id
}

"""
columns and relationships of "country"
"""
type country {
  alpha_2: String!

  alpha_3: String

  created_on: timestamp

  id: Int!

  """
  An array relationship
  """
  languages("distinct select on columns" distinct_on: [language_select_column!], "limit the number of rows returned" limit: Int, "skip the first n rows. Use only with order_by" offset: Int, "sort the rows by one or more columns" order_by: [language_order_by!], "filter the rows returned" where: language_bool_exp): [language!]!

  """
  An aggregate relationship
  """
  languages_aggregate("distinct select on columns" distinct_on: [language_select_column!], "limit the number of rows returned" limit: Int, "skip the first n rows. Use only with order_by" offset: Int, "sort the rows by one or more columns" order_by: [language_order_by!], "filter the rows returned" where: language_bool_exp): language_aggregate!

  modified_on: timestamp

  name: String!

  population: Int

  """
  An object relationship
  """
  world_region: world_region!

  world_region_id: Int!
}

"""
aggregated selection of "country"
"""
type country_aggregate {
  aggregate: country_aggregate_fields

  nodes: [country!]!
}

input country_aggregate_bool_exp {
  count: country_aggregate_bool_exp_count
}

input country_aggregate_bool_exp_count {
  arguments: [country_select_column!]

  distinct: Boolean

  filter: country_bool_exp

  predicate: Int_comparison_exp!
}

"""
aggregate fields of "country"
"""
type country_aggregate_fields {
  avg: country_avg_fields

  count(columns: [country_select_column!], distinct: Boolean): Int!

  max: country_max_fields

  min: country_min_fields

  stddev: country_stddev_fields

  stddev_pop: country_stddev_pop_fields

  stddev_samp: country_stddev_samp_fields

  sum: country_sum_fields

  var_pop: country_var_pop_fields

  var_samp: country_var_samp_fields

  variance: country_variance_fields
}

"""
order by aggregate values of table "country"
"""
input country_aggregate_order_by {
  avg: country_avg_order_by

  count: order_by

  max: country_max_order_by

  min: country_min_order_by

  stddev: country_stddev_order_by

  stddev_pop: country_stddev_pop_order_by

  stddev_samp: country_stddev_samp_order_by

  sum: country_sum_order_by

  var_pop: country_var_pop_order_by

  var_samp: country_var_samp_order_by

  variance: country_variance_order_by
}

"""
aggregate avg on columns
"""
type country_avg_fields {
  id: Float

  population: Float

  world_region_id: Float
}

"""
order by avg() on columns of table "country"
"""
input country_avg_order_by {
  id: order_by

  population: order_by

  world_region_id: order_by
}

"""
Boolean expression to filter rows from the table "country". All fields are combined with a logical 'AND'.
"""
input country_bool_exp {
  _and: [country_bool_exp!]

  _not: country_bool_exp

  _or: [country_bool_exp!]

  alpha_2: String_comparison_exp

  alpha_3: String_comparison_exp

  created_on: timestamp_comparison_exp

  id: Int_comparison_exp

  languages: language_bool_exp

  languages_aggregate: language_aggregate_bool_exp

  modified_on: timestamp_comparison_exp

  name: String_comparison_exp

  population: Int_comparison_exp

  world_region: world_region_bool_exp

  world_region_id: Int_comparison_exp
}

"""
aggregate max on columns
"""
type country_max_fields {
  alpha_2: String

  alpha_3: String

  created_on: timestamp

  id: Int

  modified_on: timestamp

  name: String

  population: Int

  world_region_id: Int
}

"""
order by max() on columns of table "country"
"""
input country_max_order_by {
  alpha_2: order_by

  alpha_3: order_by

  created_on: order_by

  id: order_by

  modified_on: order_by

  name: order_by

  population: order_by

  world_region_id: order_by
}

"""
aggregate min on columns
"""
type country_min_fields {
  alpha_2: String

  alpha_3: String

  created_on: timestamp

  id: Int

  modified_on: timestamp

  name: String

  population: Int

  world_region_id: Int
}

"""
order by min() on columns of table "country"
"""
input country_min_order_by {
  alpha_2: order_by

  alpha_3: order_by

  created_on: order_by

  id: order_by

  modified_on: order_by

  name: order_by

  population: order_by

  world_region_id: order_by
}

"""
Ordering options when selecting data from "country".
"""
input country_order_by {
  alpha_2: order_by

  alpha_3: order_by

  created_on: order_by

  id: order_by

  languages_aggregate: language_aggregate_order_by

  modified_on: order_by

  name: order_by

  population: order_by

  world_region: world_region_order_by

  world_region_id: order_by
}

"""
select columns of table "country"
"""
enum country_select_column {
  """
  column name
  """
  alpha_2

  """
  column name
  """
  alpha_3

  """
  column name
  """
  created_on

  """
  column name
  """
  id

  """
  column name
  """
  modified_on

  """
  column name
  """
  name

  """
  column name
  """
  population

  """
  column name
  """
  world_region_id
}

"""
aggregate stddev on columns
"""
type country_stddev_fields {
  id: Float

  population: Float

  world_region_id: Float
}

"""
order by stddev() on columns of table "country"
"""
input country_stddev_order_by {
  id: order_by

  population: order_by

  world_region_id: order_by
}

"""
aggregate stddev_pop on columns
"""
type country_stddev_pop_fields {
  id: Float

  population: Float

  world_region_id: Float
}

"""
order by stddev_pop() on columns of table "country"
"""
input country_stddev_pop_order_by {
  id: order_by

  population: order_by

  world_region_id: order_by
}

"""
aggregate stddev_samp on columns
"""
type country_stddev_samp_fields {
  id: Float

  population: Float

  world_region_id: Float
}

"""
order by stddev_samp() on columns of table "country"
"""
input country_stddev_samp_order_by {
  id: order_by

  population: order_by

  world_region_id: order_by
}

"""
Streaming cursor of the table "country"
"""
input country_stream_cursor_input {
  """
  Stream column input with initial value
  """
  initial_value: country_stream_cursor_value_input!

  """
  cursor ordering
  """
  ordering: cursor_ordering
}

"""
Initial value of the column from where the streaming should start
"""
input country_stream_cursor_value_input {
  alpha_2: String

  alpha_3: String

  created_on: timestamp

  id: Int

  modified_on: timestamp

  name: String

  population: Int

  world_region_id: Int
}

"""
aggregate sum on columns
"""
type country_sum_fields {
  id: Int

  population: Int

  world_region_id: Int
}

"""
order by sum() on columns of table "country"
"""
input country_sum_order_by {
  id: order_by

  population: order_by

  world_region_id: order_by
}

"""
columns and relationships of "country_to_language"
"""
type country_to_language {
  country_alpha_2: String!

  language_ietf_code: String!
}

"""
Boolean expression to filter rows from the table "country_to_language". All fields are combined with a logical 'AND'.
"""
input country_to_language_bool_exp {
  _and: [country_to_language_bool_exp!]

  _not: country_to_language_bool_exp

  _or: [country_to_language_bool_exp!]

  country_alpha_2: String_comparison_exp

  language_ietf_code: String_comparison_exp
}

"""
Ordering options when selecting data from "country_to_language".
"""
input country_to_language_order_by {
  country_alpha_2: order_by

  language_ietf_code: order_by
}

"""
select columns of table "country_to_language"
"""
enum country_to_language_select_column {
  """
  column name
  """
  country_alpha_2

  """
  column name
  """
  language_ietf_code
}

"""
Streaming cursor of the table "country_to_language"
"""
input country_to_language_stream_cursor_input {
  """
  Stream column input with initial value
  """
  initial_value: country_to_language_stream_cursor_value_input!

  """
  cursor ordering
  """
  ordering: cursor_ordering
}

"""
Initial value of the column from where the streaming should start
"""
input country_to_language_stream_cursor_value_input {
  country_alpha_2: String

  language_ietf_code: String
}

"""
aggregate var_pop on columns
"""
type country_var_pop_fields {
  id: Float

  population: Float

  world_region_id: Float
}

"""
order by var_pop() on columns of table "country"
"""
input country_var_pop_order_by {
  id: order_by

  population: order_by

  world_region_id: order_by
}

"""
aggregate var_samp on columns
"""
type country_var_samp_fields {
  id: Float

  population: Float

  world_region_id: Float
}

"""
order by var_samp() on columns of table "country"
"""
input country_var_samp_order_by {
  id: order_by

  population: order_by

  world_region_id: order_by
}

"""
aggregate variance on columns
"""
type country_variance_fields {
  id: Float

  population: Float

  world_region_id: Float
}

"""
order by variance() on columns of table "country"
"""
input country_variance_order_by {
  id: order_by

  population: order_by

  world_region_id: order_by
}

"""
ordering argument of a cursor
"""
enum cursor_ordering {
  """
  ascending ordering of the cursor
  """
  ASC

  """
  descending ordering of the cursor
  """
  DESC
}

scalar direction

"""
Boolean expression to compare columns of type "direction". All fields are combined with logical 'AND'.
"""
input direction_comparison_exp {
  _eq: direction

  _gt: direction

  _gte: direction

  _in: [direction!]

  _is_null: Boolean

  _lt: direction

  _lte: direction

  _neq: direction

  _nin: [direction!]
}

scalar domain

"""
Boolean expression to compare columns of type "domain". All fields are combined with logical 'AND'.
"""
input domain_comparison_exp {
  _eq: domain

  _gt: domain

  _gte: domain

  _in: [domain!]

  _is_null: Boolean

  _lt: domain

  _lte: domain

  _neq: domain

  _nin: [domain!]
}

"""
columns and relationships of "gateway_language_to_dependent_language"
"""
type gateway_language_to_dependent_language {
  """
  An object relationship
  """
  dependent_language: language!

  dependent_language_ietf: String!

  """
  An object relationship
  """
  gateway_language: language!

  gateway_language_ietf: String!
}

"""
aggregated selection of "gateway_language_to_dependent_language"
"""
type gateway_language_to_dependent_language_aggregate {
  aggregate: gateway_language_to_dependent_language_aggregate_fields

  nodes: [gateway_language_to_dependent_language!]!
}

input gateway_language_to_dependent_language_aggregate_bool_exp {
  count: gateway_language_to_dependent_language_aggregate_bool_exp_count
}

input gateway_language_to_dependent_language_aggregate_bool_exp_count {
  arguments: [gateway_language_to_dependent_language_select_column!]

  distinct: Boolean

  filter: gateway_language_to_dependent_language_bool_exp

  predicate: Int_comparison_exp!
}

"""
aggregate fields of "gateway_language_to_dependent_language"
"""
type gateway_language_to_dependent_language_aggregate_fields {
  count(columns: [gateway_language_to_dependent_language_select_column!], distinct: Boolean): Int!

  max: gateway_language_to_dependent_language_max_fields

  min: gateway_language_to_dependent_language_min_fields
}

"""
order by aggregate values of table "gateway_language_to_dependent_language"
"""
input gateway_language_to_dependent_language_aggregate_order_by {
  count: order_by

  max: gateway_language_to_dependent_language_max_order_by

  min: gateway_language_to_dependent_language_min_order_by
}

"""
Boolean expression to filter rows from the table "gateway_language_to_dependent_language". All fields are combined with a logical 'AND'.
"""
input gateway_language_to_dependent_language_bool_exp {
  _and: [gateway_language_to_dependent_language_bool_exp!]

  _not: gateway_language_to_dependent_language_bool_exp

  _or: [gateway_language_to_dependent_language_bool_exp!]

  dependent_language: language_bool_exp

  dependent_language_ietf: String_comparison_exp

  gateway_language: language_bool_exp

  gateway_language_ietf: String_comparison_exp
}

"""
aggregate max on columns
"""
type gateway_language_to_dependent_language_max_fields {
  dependent_language_ietf: String

  gateway_language_ietf: String
}

"""
order by max() on columns of table "gateway_language_to_dependent_language"
"""
input gateway_language_to_dependent_language_max_order_by {
  dependent_language_ietf: order_by

  gateway_language_ietf: order_by
}

"""
aggregate min on columns
"""
type gateway_language_to_dependent_language_min_fields {
  dependent_language_ietf: String

  gateway_language_ietf: String
}

"""
order by min() on columns of table "gateway_language_to_dependent_language"
"""
input gateway_language_to_dependent_language_min_order_by {
  dependent_language_ietf: order_by

  gateway_language_ietf: order_by
}

"""
Ordering options when selecting data from "gateway_language_to_dependent_language".
"""
input gateway_language_to_dependent_language_order_by {
  dependent_language: language_order_by

  dependent_language_ietf: order_by

  gateway_language: language_order_by

  gateway_language_ietf: order_by
}

"""
select columns of table "gateway_language_to_dependent_language"
"""
enum gateway_language_to_dependent_language_select_column {
  """
  column name
  """
  dependent_language_ietf

  """
  column name
  """
  gateway_language_ietf
}

"""
Streaming cursor of the table "gateway_language_to_dependent_language"
"""
input gateway_language_to_dependent_language_stream_cursor_input {
  """
  Stream column input with initial value
  """
  initial_value: gateway_language_to_dependent_language_stream_cursor_value_input!

  """
  cursor ordering
  """
  ordering: cursor_ordering
}

"""
Initial value of the column from where the streaming should start
"""
input gateway_language_to_dependent_language_stream_cursor_value_input {
  dependent_language_ietf: String

  gateway_language_ietf: String
}

"""
columns and relationships of "git_repo"
"""
type git_repo {
  """
  An object relationship
  """
  content: content!

  content_id: String!

  id: Int!

  repo_name: String!

  repo_url: String!

  username: String!
}

"""
order by aggregate values of table "git_repo"
"""
input git_repo_aggregate_order_by {
  avg: git_repo_avg_order_by

  count: order_by

  max: git_repo_max_order_by

  min: git_repo_min_order_by

  stddev: git_repo_stddev_order_by

  stddev_pop: git_repo_stddev_pop_order_by

  stddev_samp: git_repo_stddev_samp_order_by

  sum: git_repo_sum_order_by

  var_pop: git_repo_var_pop_order_by

  var_samp: git_repo_var_samp_order_by

  variance: git_repo_variance_order_by
}

"""
order by avg() on columns of table "git_repo"
"""
input git_repo_avg_order_by {
  id: order_by
}

"""
Boolean expression to filter rows from the table "git_repo". All fields are combined with a logical 'AND'.
"""
input git_repo_bool_exp {
  _and: [git_repo_bool_exp!]

  _not: git_repo_bool_exp

  _or: [git_repo_bool_exp!]

  content: content_bool_exp

  content_id: String_comparison_exp

  id: Int_comparison_exp

  repo_name: String_comparison_exp

  repo_url: String_comparison_exp

  username: String_comparison_exp
}

"""
order by max() on columns of table "git_repo"
"""
input git_repo_max_order_by {
  content_id: order_by

  id: order_by

  repo_name: order_by

  repo_url: order_by

  username: order_by
}

"""
order by min() on columns of table "git_repo"
"""
input git_repo_min_order_by {
  content_id: order_by

  id: order_by

  repo_name: order_by

  repo_url: order_by

  username: order_by
}

"""
Ordering options when selecting data from "git_repo".
"""
input git_repo_order_by {
  content: content_order_by

  content_id: order_by

  id: order_by

  repo_name: order_by

  repo_url: order_by

  username: order_by
}

"""
select columns of table "git_repo"
"""
enum git_repo_select_column {
  """
  column name
  """
  content_id

  """
  column name
  """
  id

  """
  column name
  """
  repo_name

  """
  column name
  """
  repo_url

  """
  column name
  """
  username
}

"""
order by stddev() on columns of table "git_repo"
"""
input git_repo_stddev_order_by {
  id: order_by
}

"""
order by stddev_pop() on columns of table "git_repo"
"""
input git_repo_stddev_pop_order_by {
  id: order_by
}

"""
order by stddev_samp() on columns of table "git_repo"
"""
input git_repo_stddev_samp_order_by {
  id: order_by
}

"""
Streaming cursor of the table "git_repo"
"""
input git_repo_stream_cursor_input {
  """
  Stream column input with initial value
  """
  initial_value: git_repo_stream_cursor_value_input!

  """
  cursor ordering
  """
  ordering: cursor_ordering
}

"""
Initial value of the column from where the streaming should start
"""
input git_repo_stream_cursor_value_input {
  content_id: String

  id: Int

  repo_name: String

  repo_url: String

  username: String
}

"""
order by sum() on columns of table "git_repo"
"""
input git_repo_sum_order_by {
  id: order_by
}

"""
order by var_pop() on columns of table "git_repo"
"""
input git_repo_var_pop_order_by {
  id: order_by
}

"""
order by var_samp() on columns of table "git_repo"
"""
input git_repo_var_samp_order_by {
  id: order_by
}

"""
order by variance() on columns of table "git_repo"
"""
input git_repo_variance_order_by {
  id: order_by
}

scalar json

"""
Boolean expression to compare columns of type "json". All fields are combined with logical 'AND'.
"""
input json_comparison_exp {
  _eq: json

  _gt: json

  _gte: json

  _in: [json!]

  _is_null: Boolean

  _lt: json

  _lte: json

  _neq: json

  _nin: [json!]
}

"""
columns and relationships of "language"
"""
type language {
  """
  An array relationship
  """
  contents("distinct select on columns" distinct_on: [content_select_column!], "limit the number of rows returned" limit: Int, "skip the first n rows. Use only with order_by" offset: Int, "sort the rows by one or more columns" order_by: [content_order_by!], "filter the rows returned" where: content_bool_exp): [content!]!

  """
  An aggregate relationship
  """
  contents_aggregate("distinct select on columns" distinct_on: [content_select_column!], "limit the number of rows returned" limit: Int, "skip the first n rows. Use only with order_by" offset: Int, "sort the rows by one or more columns" order_by: [content_order_by!], "filter the rows returned" where: content_bool_exp): content_aggregate!

  """
  An object relationship
  """
  country: country!

  created_on: timestamp

  """
  An array relationship
  """
  dependent_languages("distinct select on columns" distinct_on: [gateway_language_to_dependent_language_select_column!], "limit the number of rows returned" limit: Int, "skip the first n rows. Use only with order_by" offset: Int, "sort the rows by one or more columns" order_by: [gateway_language_to_dependent_language_order_by!], "filter the rows returned" where: gateway_language_to_dependent_language_bool_exp): [gateway_language_to_dependent_language!]!

  """
  An aggregate relationship
  """
  dependent_languages_aggregate("distinct select on columns" distinct_on: [gateway_language_to_dependent_language_select_column!], "limit the number of rows returned" limit: Int, "skip the first n rows. Use only with order_by" offset: Int, "sort the rows by one or more columns" order_by: [gateway_language_to_dependent_language_order_by!], "filter the rows returned" where: gateway_language_to_dependent_language_bool_exp): gateway_language_to_dependent_language_aggregate!

  direction: direction!

  english_name: String!

  """
  An array relationship
  """
  gateway_languages("distinct select on columns" distinct_on: [gateway_language_to_dependent_language_select_column!], "limit the number of rows returned" limit: Int, "skip the first n rows. Use only with order_by" offset: Int, "sort the rows by one or more columns" order_by: [gateway_language_to_dependent_language_order_by!], "filter the rows returned" where: gateway_language_to_dependent_language_bool_exp): [gateway_language_to_dependent_language!]!

  """
  An aggregate relationship
  """
  gateway_languages_aggregate("distinct select on columns" distinct_on: [gateway_language_to_dependent_language_select_column!], "limit the number of rows returned" limit: Int, "skip the first n rows. Use only with order_by" offset: Int, "sort the rows by one or more columns" order_by: [gateway_language_to_dependent_language_order_by!], "filter the rows returned" where: gateway_language_to_dependent_language_bool_exp): gateway_language_to_dependent_language_aggregate!

  home_country_alpha2: String!

  id: String!

  ietf_code: String!

  is_oral_language: Boolean

  iso6393: String

  """
  An array relationship
  """
  language_alternate_names("distinct select on columns" distinct_on: [language_alternate_name_select_column!], "limit the number of rows returned" limit: Int, "skip the first n rows. Use only with order_by" offset: Int, "sort the rows by one or more columns" order_by: [language_alternate_name_order_by!], "filter the rows returned" where: language_alternate_name_bool_exp): [language_alternate_name!]!

  """
  An aggregate relationship
  """
  language_alternate_names_aggregate("distinct select on columns" distinct_on: [language_alternate_name_select_column!], "limit the number of rows returned" limit: Int, "skip the first n rows. Use only with order_by" offset: Int, "sort the rows by one or more columns" order_by: [language_alternate_name_order_by!], "filter the rows returned" where: language_alternate_name_bool_exp): language_alternate_name_aggregate!

  """
  An array relationship
  """
  localizations("distinct select on columns" distinct_on: [localization_select_column!], "limit the number of rows returned" limit: Int, "skip the first n rows. Use only with order_by" offset: Int, "sort the rows by one or more columns" order_by: [localization_order_by!], "filter the rows returned" where: localization_bool_exp): [localization!]!

  modified_on: timestamp

  national_name: String!

  """
  An object relationship
  """
  wa_language_metadata: wa_language_metadata
}

"""
aggregated selection of "language"
"""
type language_aggregate {
  aggregate: language_aggregate_fields

  nodes: [language!]!
}

input language_aggregate_bool_exp {
  bool_and: language_aggregate_bool_exp_bool_and

  bool_or: language_aggregate_bool_exp_bool_or

  count: language_aggregate_bool_exp_count
}

input language_aggregate_bool_exp_bool_and {
  arguments: language_select_column_language_aggregate_bool_exp_bool_and_arguments_columns!

  distinct: Boolean

  filter: language_bool_exp

  predicate: Boolean_comparison_exp!
}

input language_aggregate_bool_exp_bool_or {
  arguments: language_select_column_language_aggregate_bool_exp_bool_or_arguments_columns!

  distinct: Boolean

  filter: language_bool_exp

  predicate: Boolean_comparison_exp!
}

input language_aggregate_bool_exp_count {
  arguments: [language_select_column!]

  distinct: Boolean

  filter: language_bool_exp

  predicate: Int_comparison_exp!
}

"""
aggregate fields of "language"
"""
type language_aggregate_fields {
  count(columns: [language_select_column!], distinct: Boolean): Int!

  max: language_max_fields

  min: language_min_fields
}

"""
order by aggregate values of table "language"
"""
input language_aggregate_order_by {
  count: order_by

  max: language_max_order_by

  min: language_min_order_by
}

"""
columns and relationships of "language_alternate_name"
"""
type language_alternate_name {
  id: Int!

  ietf_code: String!

  """
  An object relationship
  """
  language: language!

  name: String!
}

"""
aggregated selection of "language_alternate_name"
"""
type language_alternate_name_aggregate {
  aggregate: language_alternate_name_aggregate_fields

  nodes: [language_alternate_name!]!
}

input language_alternate_name_aggregate_bool_exp {
  count: language_alternate_name_aggregate_bool_exp_count
}

input language_alternate_name_aggregate_bool_exp_count {
  arguments: [language_alternate_name_select_column!]

  distinct: Boolean

  filter: language_alternate_name_bool_exp

  predicate: Int_comparison_exp!
}

"""
aggregate fields of "language_alternate_name"
"""
type language_alternate_name_aggregate_fields {
  avg: language_alternate_name_avg_fields

  count(columns: [language_alternate_name_select_column!], distinct: Boolean): Int!

  max: language_alternate_name_max_fields

  min: language_alternate_name_min_fields

  stddev: language_alternate_name_stddev_fields

  stddev_pop: language_alternate_name_stddev_pop_fields

  stddev_samp: language_alternate_name_stddev_samp_fields

  sum: language_alternate_name_sum_fields

  var_pop: language_alternate_name_var_pop_fields

  var_samp: language_alternate_name_var_samp_fields

  variance: language_alternate_name_variance_fields
}

"""
order by aggregate values of table "language_alternate_name"
"""
input language_alternate_name_aggregate_order_by {
  avg: language_alternate_name_avg_order_by

  count: order_by

  max: language_alternate_name_max_order_by

  min: language_alternate_name_min_order_by

  stddev: language_alternate_name_stddev_order_by

  stddev_pop: language_alternate_name_stddev_pop_order_by

  stddev_samp: language_alternate_name_stddev_samp_order_by

  sum: language_alternate_name_sum_order_by

  var_pop: language_alternate_name_var_pop_order_by

  var_samp: language_alternate_name_var_samp_order_by

  variance: language_alternate_name_variance_order_by
}

"""
aggregate avg on columns
"""
type language_alternate_name_avg_fields {
  id: Float
}

"""
order by avg() on columns of table "language_alternate_name"
"""
input language_alternate_name_avg_order_by {
  id: order_by
}

"""
Boolean expression to filter rows from the table "language_alternate_name". All fields are combined with a logical 'AND'.
"""
input language_alternate_name_bool_exp {
  _and: [language_alternate_name_bool_exp!]

  _not: language_alternate_name_bool_exp

  _or: [language_alternate_name_bool_exp!]

  id: Int_comparison_exp

  ietf_code: String_comparison_exp

  language: language_bool_exp

  name: String_comparison_exp
}

"""
aggregate max on columns
"""
type language_alternate_name_max_fields {
  id: Int

  ietf_code: String

  name: String
}

"""
order by max() on columns of table "language_alternate_name"
"""
input language_alternate_name_max_order_by {
  id: order_by

  ietf_code: order_by

  name: order_by
}

"""
aggregate min on columns
"""
type language_alternate_name_min_fields {
  id: Int

  ietf_code: String

  name: String
}

"""
order by min() on columns of table "language_alternate_name"
"""
input language_alternate_name_min_order_by {
  id: order_by

  ietf_code: order_by

  name: order_by
}

"""
Ordering options when selecting data from "language_alternate_name".
"""
input language_alternate_name_order_by {
  id: order_by

  ietf_code: order_by

  language: language_order_by

  name: order_by
}

"""
select columns of table "language_alternate_name"
"""
enum language_alternate_name_select_column {
  """
  column name
  """
  id

  """
  column name
  """
  ietf_code

  """
  column name
  """
  name
}

"""
aggregate stddev on columns
"""
type language_alternate_name_stddev_fields {
  id: Float
}

"""
order by stddev() on columns of table "language_alternate_name"
"""
input language_alternate_name_stddev_order_by {
  id: order_by
}

"""
aggregate stddev_pop on columns
"""
type language_alternate_name_stddev_pop_fields {
  id: Float
}

"""
order by stddev_pop() on columns of table "language_alternate_name"
"""
input language_alternate_name_stddev_pop_order_by {
  id: order_by
}

"""
aggregate stddev_samp on columns
"""
type language_alternate_name_stddev_samp_fields {
  id: Float
}

"""
order by stddev_samp() on columns of table "language_alternate_name"
"""
input language_alternate_name_stddev_samp_order_by {
  id: order_by
}

"""
Streaming cursor of the table "language_alternate_name"
"""
input language_alternate_name_stream_cursor_input {
  """
  Stream column input with initial value
  """
  initial_value: language_alternate_name_stream_cursor_value_input!

  """
  cursor ordering
  """
  ordering: cursor_ordering
}

"""
Initial value of the column from where the streaming should start
"""
input language_alternate_name_stream_cursor_value_input {
  id: Int

  ietf_code: String

  name: String
}

"""
aggregate sum on columns
"""
type language_alternate_name_sum_fields {
  id: Int
}

"""
order by sum() on columns of table "language_alternate_name"
"""
input language_alternate_name_sum_order_by {
  id: order_by
}

"""
aggregate var_pop on columns
"""
type language_alternate_name_var_pop_fields {
  id: Float
}

"""
order by var_pop() on columns of table "language_alternate_name"
"""
input language_alternate_name_var_pop_order_by {
  id: order_by
}

"""
aggregate var_samp on columns
"""
type language_alternate_name_var_samp_fields {
  id: Float
}

"""
order by var_samp() on columns of table "language_alternate_name"
"""
input language_alternate_name_var_samp_order_by {
  id: order_by
}

"""
aggregate variance on columns
"""
type language_alternate_name_variance_fields {
  id: Float
}

"""
order by variance() on columns of table "language_alternate_name"
"""
input language_alternate_name_variance_order_by {
  id: order_by
}

"""
Boolean expression to filter rows from the table "language". All fields are combined with a logical 'AND'.
"""
input language_bool_exp {
  _and: [language_bool_exp!]

  _not: language_bool_exp

  _or: [language_bool_exp!]

  contents: content_bool_exp

  contents_aggregate: content_aggregate_bool_exp

  country: country_bool_exp

  created_on: timestamp_comparison_exp

  dependent_languages: gateway_language_to_dependent_language_bool_exp

  dependent_languages_aggregate: gateway_language_to_dependent_language_aggregate_bool_exp

  direction: direction_comparison_exp

  english_name: String_comparison_exp

  gateway_languages: gateway_language_to_dependent_language_bool_exp

  gateway_languages_aggregate: gateway_language_to_dependent_language_aggregate_bool_exp

  home_country_alpha2: String_comparison_exp

  id: String_comparison_exp

  ietf_code: String_comparison_exp

  is_oral_language: Boolean_comparison_exp

  iso6393: String_comparison_exp

  language_alternate_names: language_alternate_name_bool_exp

  language_alternate_names_aggregate: language_alternate_name_aggregate_bool_exp

  localizations: localization_bool_exp

  modified_on: timestamp_comparison_exp

  national_name: String_comparison_exp

  wa_language_metadata: wa_language_metadata_bool_exp
}

"""
aggregate max on columns
"""
type language_max_fields {
  created_on: timestamp

  direction: direction

  english_name: String

  home_country_alpha2: String

  id: String

  ietf_code: String

  iso6393: String

  modified_on: timestamp

  national_name: String
}

"""
order by max() on columns of table "language"
"""
input language_max_order_by {
  created_on: order_by

  direction: order_by

  english_name: order_by

  home_country_alpha2: order_by

  id: order_by

  ietf_code: order_by

  iso6393: order_by

  modified_on: order_by

  national_name: order_by
}

"""
aggregate min on columns
"""
type language_min_fields {
  created_on: timestamp

  direction: direction

  english_name: String

  home_country_alpha2: String

  id: String

  ietf_code: String

  iso6393: String

  modified_on: timestamp

  national_name: String
}

"""
order by min() on columns of table "language"
"""
input language_min_order_by {
  created_on: order_by

  direction: order_by

  english_name: order_by

  home_country_alpha2: order_by

  id: order_by

  ietf_code: order_by

  iso6393: order_by

  modified_on: order_by

  national_name: order_by
}

"""
Ordering options when selecting data from "language".
"""
input language_order_by {
  contents_aggregate: content_aggregate_order_by

  country: country_order_by

  created_on: order_by

  dependent_languages_aggregate: gateway_language_to_dependent_language_aggregate_order_by

  direction: order_by

  english_name: order_by

  gateway_languages_aggregate: gateway_language_to_dependent_language_aggregate_order_by

  home_country_alpha2: order_by

  id: order_by

  ietf_code: order_by

  is_oral_language: order_by

  iso6393: order_by

  language_alternate_names_aggregate: language_alternate_name_aggregate_order_by

  localizations_aggregate: localization_aggregate_order_by

  modified_on: order_by

  national_name: order_by

  wa_language_metadata: wa_language_metadata_order_by
}

"""
select columns of table "language"
"""
enum language_select_column {
  """
  column name
  """
  created_on

  """
  column name
  """
  direction

  """
  column name
  """
  english_name

  """
  column name
  """
  home_country_alpha2

  """
  column name
  """
  id

  """
  column name
  """
  ietf_code

  """
  column name
  """
  is_oral_language

  """
  column name
  """
  iso6393

  """
  column name
  """
  modified_on

  """
  column name
  """
  national_name
}

"""
select "language_aggregate_bool_exp_bool_and_arguments_columns" columns of table "language"
"""
enum language_select_column_language_aggregate_bool_exp_bool_and_arguments_columns {
  """
  column name
  """
  is_oral_language
}

"""
select "language_aggregate_bool_exp_bool_or_arguments_columns" columns of table "language"
"""
enum language_select_column_language_aggregate_bool_exp_bool_or_arguments_columns {
  """
  column name
  """
  is_oral_language
}

"""
Streaming cursor of the table "language"
"""
input language_stream_cursor_input {
  """
  Stream column input with initial value
  """
  initial_value: language_stream_cursor_value_input!

  """
  cursor ordering
  """
  ordering: cursor_ordering
}

"""
Initial value of the column from where the streaming should start
"""
input language_stream_cursor_value_input {
  created_on: timestamp

  direction: direction

  english_name: String

  home_country_alpha2: String

  id: String

  ietf_code: String

  is_oral_language: Boolean

  iso6393: String

  modified_on: timestamp

  national_name: String
}

"""
columns and relationships of "localization"
"""
type localization {
  category: String!

  ietf_code: String!

  key: String!

  """
  An object relationship
  """
  language: language!

  value: String!
}

"""
order by aggregate values of table "localization"
"""
input localization_aggregate_order_by {
  count: order_by

  max: localization_max_order_by

  min: localization_min_order_by
}

"""
Boolean expression to filter rows from the table "localization". All fields are combined with a logical 'AND'.
"""
input localization_bool_exp {
  _and: [localization_bool_exp!]

  _not: localization_bool_exp

  _or: [localization_bool_exp!]

  category: String_comparison_exp

  ietf_code: String_comparison_exp

  key: String_comparison_exp

  language: language_bool_exp

  value: String_comparison_exp
}

"""
order by max() on columns of table "localization"
"""
input localization_max_order_by {
  category: order_by

  ietf_code: order_by

  key: order_by

  value: order_by
}

"""
order by min() on columns of table "localization"
"""
input localization_min_order_by {
  category: order_by

  ietf_code: order_by

  key: order_by

  value: order_by
}

"""
Ordering options when selecting data from "localization".
"""
input localization_order_by {
  category: order_by

  ietf_code: order_by

  key: order_by

  language: language_order_by

  value: order_by
}

"""
select columns of table "localization"
"""
enum localization_select_column {
  """
  column name
  """
  category

  """
  column name
  """
  ietf_code

  """
  column name
  """
  key

  """
  column name
  """
  value
}

"""
Streaming cursor of the table "localization"
"""
input localization_stream_cursor_input {
  """
  Stream column input with initial value
  """
  initial_value: localization_stream_cursor_value_input!

  """
  cursor ordering
  """
  ordering: cursor_ordering
}

"""
Initial value of the column from where the streaming should start
"""
input localization_stream_cursor_value_input {
  category: String

  ietf_code: String

  key: String

  value: String
}

"""
columns and relationships of "nonscriptural_rendering_metadata"
"""
type nonscriptural_rendering_metadata {
  additional_data("JSON select path" path: String): json

  id: Int!

  name: String

  """
  An object relationship
  """
  rendered_content: rendered_content!

  rendering_id: Int!
}

"""
order by aggregate values of table "nonscriptural_rendering_metadata"
"""
input nonscriptural_rendering_metadata_aggregate_order_by {
  avg: nonscriptural_rendering_metadata_avg_order_by

  count: order_by

  max: nonscriptural_rendering_metadata_max_order_by

  min: nonscriptural_rendering_metadata_min_order_by

  stddev: nonscriptural_rendering_metadata_stddev_order_by

  stddev_pop: nonscriptural_rendering_metadata_stddev_pop_order_by

  stddev_samp: nonscriptural_rendering_metadata_stddev_samp_order_by

  sum: nonscriptural_rendering_metadata_sum_order_by

  var_pop: nonscriptural_rendering_metadata_var_pop_order_by

  var_samp: nonscriptural_rendering_metadata_var_samp_order_by

  variance: nonscriptural_rendering_metadata_variance_order_by
}

"""
order by avg() on columns of table "nonscriptural_rendering_metadata"
"""
input nonscriptural_rendering_metadata_avg_order_by {
  id: order_by

  rendering_id: order_by
}

"""
Boolean expression to filter rows from the table "nonscriptural_rendering_metadata". All fields are combined with a logical 'AND'.
"""
input nonscriptural_rendering_metadata_bool_exp {
  _and: [nonscriptural_rendering_metadata_bool_exp!]

  _not: nonscriptural_rendering_metadata_bool_exp

  _or: [nonscriptural_rendering_metadata_bool_exp!]

  additional_data: json_comparison_exp

  id: Int_comparison_exp

  name: String_comparison_exp

  rendered_content: rendered_content_bool_exp

  rendering_id: Int_comparison_exp
}

"""
order by max() on columns of table "nonscriptural_rendering_metadata"
"""
input nonscriptural_rendering_metadata_max_order_by {
  id: order_by

  name: order_by

  rendering_id: order_by
}

"""
order by min() on columns of table "nonscriptural_rendering_metadata"
"""
input nonscriptural_rendering_metadata_min_order_by {
  id: order_by

  name: order_by

  rendering_id: order_by
}

"""
Ordering options when selecting data from "nonscriptural_rendering_metadata".
"""
input nonscriptural_rendering_metadata_order_by {
  additional_data: order_by

  id: order_by

  name: order_by

  rendered_content: rendered_content_order_by

  rendering_id: order_by
}

"""
select columns of table "nonscriptural_rendering_metadata"
"""
enum nonscriptural_rendering_metadata_select_column {
  """
  column name
  """
  additional_data

  """
  column name
  """
  id

  """
  column name
  """
  name

  """
  column name
  """
  rendering_id
}

"""
order by stddev() on columns of table "nonscriptural_rendering_metadata"
"""
input nonscriptural_rendering_metadata_stddev_order_by {
  id: order_by

  rendering_id: order_by
}

"""
order by stddev_pop() on columns of table "nonscriptural_rendering_metadata"
"""
input nonscriptural_rendering_metadata_stddev_pop_order_by {
  id: order_by

  rendering_id: order_by
}

"""
order by stddev_samp() on columns of table "nonscriptural_rendering_metadata"
"""
input nonscriptural_rendering_metadata_stddev_samp_order_by {
  id: order_by

  rendering_id: order_by
}

"""
Streaming cursor of the table "nonscriptural_rendering_metadata"
"""
input nonscriptural_rendering_metadata_stream_cursor_input {
  """
  Stream column input with initial value
  """
  initial_value: nonscriptural_rendering_metadata_stream_cursor_value_input!

  """
  cursor ordering
  """
  ordering: cursor_ordering
}

"""
Initial value of the column from where the streaming should start
"""
input nonscriptural_rendering_metadata_stream_cursor_value_input {
  additional_data: json

  id: Int

  name: String

  rendering_id: Int
}

"""
order by sum() on columns of table "nonscriptural_rendering_metadata"
"""
input nonscriptural_rendering_metadata_sum_order_by {
  id: order_by

  rendering_id: order_by
}

"""
order by var_pop() on columns of table "nonscriptural_rendering_metadata"
"""
input nonscriptural_rendering_metadata_var_pop_order_by {
  id: order_by

  rendering_id: order_by
}

"""
order by var_samp() on columns of table "nonscriptural_rendering_metadata"
"""
input nonscriptural_rendering_metadata_var_samp_order_by {
  id: order_by

  rendering_id: order_by
}

"""
order by variance() on columns of table "nonscriptural_rendering_metadata"
"""
input nonscriptural_rendering_metadata_variance_order_by {
  id: order_by

  rendering_id: order_by
}

"""
column ordering options
"""
enum order_by {
  """
  in ascending order, nulls last
  """
  asc

  """
  in ascending order, nulls first
  """
  asc_nulls_first

  """
  in ascending order, nulls last
  """
  asc_nulls_last

  """
  in descending order, nulls first
  """
  desc

  """
  in descending order, nulls first
  """
  desc_nulls_first

  """
  in descending order, nulls last
  """
  desc_nulls_last
}

type query_root {
  """
  fetch data from the table: "content"
  """
  content("distinct select on columns" distinct_on: [content_select_column!], "limit the number of rows returned" limit: Int, "skip the first n rows. Use only with order_by" offset: Int, "sort the rows by one or more columns" order_by: [content_order_by!], "filter the rows returned" where: content_bool_exp): [content!]!

  """
  fetch aggregated fields from the table: "content"
  """
  content_aggregate("distinct select on columns" distinct_on: [content_select_column!], "limit the number of rows returned" limit: Int, "skip the first n rows. Use only with order_by" offset: Int, "sort the rows by one or more columns" order_by: [content_order_by!], "filter the rows returned" where: content_bool_exp): content_aggregate!

  """
  fetch data from the table: "content" using primary key columns
  """
  content_by_pk(id: String!): content

  """
  fetch data from the table: "country"
  """
  country("distinct select on columns" distinct_on: [country_select_column!], "limit the number of rows returned" limit: Int, "skip the first n rows. Use only with order_by" offset: Int, "sort the rows by one or more columns" order_by: [country_order_by!], "filter the rows returned" where: country_bool_exp): [country!]!

  """
  fetch aggregated fields from the table: "country"
  """
  country_aggregate("distinct select on columns" distinct_on: [country_select_column!], "limit the number of rows returned" limit: Int, "skip the first n rows. Use only with order_by" offset: Int, "sort the rows by one or more columns" order_by: [country_order_by!], "filter the rows returned" where: country_bool_exp): country_aggregate!

  """
  fetch data from the table: "country" using primary key columns
  """
  country_by_pk(id: Int!): country

  """
  fetch data from the table: "country_to_language"
  """
  country_to_language("distinct select on columns" distinct_on: [country_to_language_select_column!], "limit the number of rows returned" limit: Int, "skip the first n rows. Use only with order_by" offset: Int, "sort the rows by one or more columns" order_by: [country_to_language_order_by!], "filter the rows returned" where: country_to_language_bool_exp): [country_to_language!]!

  """
  fetch data from the table: "country_to_language" using primary key columns
  """
  country_to_language_by_pk(country_alpha_2: String!, language_ietf_code: String!): country_to_language

  """
  fetch data from the table: "gateway_language_to_dependent_language"
  """
  gateway_language_to_dependent_language("distinct select on columns" distinct_on: [gateway_language_to_dependent_language_select_column!], "limit the number of rows returned" limit: Int, "skip the first n rows. Use only with order_by" offset: Int, "sort the rows by one or more columns" order_by: [gateway_language_to_dependent_language_order_by!], "filter the rows returned" where: gateway_language_to_dependent_language_bool_exp): [gateway_language_to_dependent_language!]!

  """
  fetch aggregated fields from the table: "gateway_language_to_dependent_language"
  """
  gateway_language_to_dependent_language_aggregate("distinct select on columns" distinct_on: [gateway_language_to_dependent_language_select_column!], "limit the number of rows returned" limit: Int, "skip the first n rows. Use only with order_by" offset: Int, "sort the rows by one or more columns" order_by: [gateway_language_to_dependent_language_order_by!], "filter the rows returned" where: gateway_language_to_dependent_language_bool_exp): gateway_language_to_dependent_language_aggregate!

  """
  fetch data from the table: "gateway_language_to_dependent_language" using primary key columns
  """
  gateway_language_to_dependent_language_by_pk(dependent_language_ietf: String!, gateway_language_ietf: String!): gateway_language_to_dependent_language

  """
  fetch data from the table: "git_repo"
  """
  git_repo("distinct select on columns" distinct_on: [git_repo_select_column!], "limit the number of rows returned" limit: Int, "skip the first n rows. Use only with order_by" offset: Int, "sort the rows by one or more columns" order_by: [git_repo_order_by!], "filter the rows returned" where: git_repo_bool_exp): [git_repo!]!

  """
  fetch data from the table: "git_repo" using primary key columns
  """
  git_repo_by_pk(id: Int!): git_repo

  """
  fetch data from the table: "language"
  """
  language("distinct select on columns" distinct_on: [language_select_column!], "limit the number of rows returned" limit: Int, "skip the first n rows. Use only with order_by" offset: Int, "sort the rows by one or more columns" order_by: [language_order_by!], "filter the rows returned" where: language_bool_exp): [language!]!

  """
  fetch aggregated fields from the table: "language"
  """
  language_aggregate("distinct select on columns" distinct_on: [language_select_column!], "limit the number of rows returned" limit: Int, "skip the first n rows. Use only with order_by" offset: Int, "sort the rows by one or more columns" order_by: [language_order_by!], "filter the rows returned" where: language_bool_exp): language_aggregate!

  """
  fetch data from the table: "language_alternate_name"
  """
  language_alternate_name("distinct select on columns" distinct_on: [language_alternate_name_select_column!], "limit the number of rows returned" limit: Int, "skip the first n rows. Use only with order_by" offset: Int, "sort the rows by one or more columns" order_by: [language_alternate_name_order_by!], "filter the rows returned" where: language_alternate_name_bool_exp): [language_alternate_name!]!

  """
  fetch aggregated fields from the table: "language_alternate_name"
  """
  language_alternate_name_aggregate("distinct select on columns" distinct_on: [language_alternate_name_select_column!], "limit the number of rows returned" limit: Int, "skip the first n rows. Use only with order_by" offset: Int, "sort the rows by one or more columns" order_by: [language_alternate_name_order_by!], "filter the rows returned" where: language_alternate_name_bool_exp): language_alternate_name_aggregate!

  """
  fetch data from the table: "language_alternate_name" using primary key columns
  """
  language_alternate_name_by_pk(id: Int!): language_alternate_name

  """
  fetch data from the table: "language" using primary key columns
  """
  language_by_pk(ietf_code: String!): language

  """
  fetch data from the table: "localization"
  """
  localization("distinct select on columns" distinct_on: [localization_select_column!], "limit the number of rows returned" limit: Int, "skip the first n rows. Use only with order_by" offset: Int, "sort the rows by one or more columns" order_by: [localization_order_by!], "filter the rows returned" where: localization_bool_exp): [localization!]!

  """
  fetch data from the table: "localization" using primary key columns
  """
  localization_by_pk(category: String!, ietf_code: String!, key: String!): localization

  """
  fetch data from the table: "nonscriptural_rendering_metadata"
  """
  nonscriptural_rendering_metadata("distinct select on columns" distinct_on: [nonscriptural_rendering_metadata_select_column!], "limit the number of rows returned" limit: Int, "skip the first n rows. Use only with order_by" offset: Int, "sort the rows by one or more columns" order_by: [nonscriptural_rendering_metadata_order_by!], "filter the rows returned" where: nonscriptural_rendering_metadata_bool_exp): [nonscriptural_rendering_metadata!]!

  """
  fetch data from the table: "nonscriptural_rendering_metadata" using primary key columns
  """
  nonscriptural_rendering_metadata_by_pk(id: Int!): nonscriptural_rendering_metadata

  """
  fetch data from the table: "rendered_content"
  """
  rendered_content("distinct select on columns" distinct_on: [rendered_content_select_column!], "limit the number of rows returned" limit: Int, "skip the first n rows. Use only with order_by" offset: Int, "sort the rows by one or more columns" order_by: [rendered_content_order_by!], "filter the rows returned" where: rendered_content_bool_exp): [rendered_content!]!

  """
  fetch aggregated fields from the table: "rendered_content"
  """
  rendered_content_aggregate("distinct select on columns" distinct_on: [rendered_content_select_column!], "limit the number of rows returned" limit: Int, "skip the first n rows. Use only with order_by" offset: Int, "sort the rows by one or more columns" order_by: [rendered_content_order_by!], "filter the rows returned" where: rendered_content_bool_exp): rendered_content_aggregate!

  """
  fetch data from the table: "rendered_content" using primary key columns
  """
  rendered_content_by_pk(id: Int!): rendered_content

  """
  fetch data from the table: "scriptural_rendering_metadata"
  """
  scriptural_rendering_metadata("distinct select on columns" distinct_on: [scriptural_rendering_metadata_select_column!], "limit the number of rows returned" limit: Int, "skip the first n rows. Use only with order_by" offset: Int, "sort the rows by one or more columns" order_by: [scriptural_rendering_metadata_order_by!], "filter the rows returned" where: scriptural_rendering_metadata_bool_exp): [scriptural_rendering_metadata!]!

  """
  fetch data from the table: "scriptural_rendering_metadata" using primary key columns
  """
  scriptural_rendering_metadata_by_pk(id: Int!): scriptural_rendering_metadata

  """
  fetch data from the table: "source_zips"
  """
  source_zips("distinct select on columns" distinct_on: [source_zips_select_column!], "limit the number of rows returned" limit: Int, "skip the first n rows. Use only with order_by" offset: Int, "sort the rows by one or more columns" order_by: [source_zips_order_by!], "filter the rows returned" where: source_zips_bool_exp): [source_zips!]!

  """
  fetch data from the table: "vw_langnames"
  """
  vw_langnames("distinct select on columns" distinct_on: [vw_langnames_select_column!], "limit the number of rows returned" limit: Int, "skip the first n rows. Use only with order_by" offset: Int, "sort the rows by one or more columns" order_by: [vw_langnames_order_by!], "filter the rows returned" where: vw_langnames_bool_exp): [vw_langnames!]!

  """
  fetch data from the table: "wa_content_metadata"
  """
  wa_content_metadata("distinct select on columns" distinct_on: [wa_content_metadata_select_column!], "limit the number of rows returned" limit: Int, "skip the first n rows. Use only with order_by" offset: Int, "sort the rows by one or more columns" order_by: [wa_content_metadata_order_by!], "filter the rows returned" where: wa_content_metadata_bool_exp): [wa_content_metadata!]!

  """
  fetch data from the table: "wa_content_metadata" using primary key columns
  """
  wa_content_metadata_by_pk(id: Int!): wa_content_metadata

  """
  fetch data from the table: "wa_language_metadata"
  """
  wa_language_metadata("distinct select on columns" distinct_on: [wa_language_metadata_select_column!], "limit the number of rows returned" limit: Int, "skip the first n rows. Use only with order_by" offset: Int, "sort the rows by one or more columns" order_by: [wa_language_metadata_order_by!], "filter the rows returned" where: wa_language_metadata_bool_exp): [wa_language_metadata!]!

  """
  fetch data from the table: "wa_language_metadata" using primary key columns
  """
  wa_language_metadata_by_pk(id: Int!): wa_language_metadata

  """
  fetch data from the table: "world_region"
  """
  world_region("distinct select on columns" distinct_on: [world_region_select_column!], "limit the number of rows returned" limit: Int, "skip the first n rows. Use only with order_by" offset: Int, "sort the rows by one or more columns" order_by: [world_region_order_by!], "filter the rows returned" where: world_region_bool_exp): [world_region!]!

  """
  fetch data from the table: "world_region" using primary key columns
  """
  world_region_by_pk(id: Int!): world_region
}

"""
columns and relationships of "rendered_content"
"""
type rendered_content {
  """
  An object relationship
  """
  content: content!

  content_id: String!

  created_at: timestamp

  file_size_bytes: bigint

  file_type: String!

  hash: String

  id: Int!

  modified_on: timestamp

  """
  An array relationship
  """
  nonscripturalRenderingMetadataByRenderingId("distinct select on columns" distinct_on: [nonscriptural_rendering_metadata_select_column!], "limit the number of rows returned" limit: Int, "skip the first n rows. Use only with order_by" offset: Int, "sort the rows by one or more columns" order_by: [nonscriptural_rendering_metadata_order_by!], "filter the rows returned" where: nonscriptural_rendering_metadata_bool_exp): [nonscriptural_rendering_metadata!]!

  """
  An object relationship
  """
  nonscriptural_rendering_metadata: nonscriptural_rendering_metadata

  """
  An object relationship
  """
  scriptural_rendering_metadata: scriptural_rendering_metadata

  url: String!
}

"""
aggregated selection of "rendered_content"
"""
type rendered_content_aggregate {
  aggregate: rendered_content_aggregate_fields

  nodes: [rendered_content!]!
}

input rendered_content_aggregate_bool_exp {
  count: rendered_content_aggregate_bool_exp_count
}

input rendered_content_aggregate_bool_exp_count {
  arguments: [rendered_content_select_column!]

  distinct: Boolean

  filter: rendered_content_bool_exp

  predicate: Int_comparison_exp!
}

"""
aggregate fields of "rendered_content"
"""
type rendered_content_aggregate_fields {
  avg: rendered_content_avg_fields

  count(columns: [rendered_content_select_column!], distinct: Boolean): Int!

  max: rendered_content_max_fields

  min: rendered_content_min_fields

  stddev: rendered_content_stddev_fields

  stddev_pop: rendered_content_stddev_pop_fields

  stddev_samp: rendered_content_stddev_samp_fields

  sum: rendered_content_sum_fields

  var_pop: rendered_content_var_pop_fields

  var_samp: rendered_content_var_samp_fields

  variance: rendered_content_variance_fields
}

"""
order by aggregate values of table "rendered_content"
"""
input rendered_content_aggregate_order_by {
  avg: rendered_content_avg_order_by

  count: order_by

  max: rendered_content_max_order_by

  min: rendered_content_min_order_by

  stddev: rendered_content_stddev_order_by

  stddev_pop: rendered_content_stddev_pop_order_by

  stddev_samp: rendered_content_stddev_samp_order_by

  sum: rendered_content_sum_order_by

  var_pop: rendered_content_var_pop_order_by

  var_samp: rendered_content_var_samp_order_by

  variance: rendered_content_variance_order_by
}

"""
aggregate avg on columns
"""
type rendered_content_avg_fields {
  file_size_bytes: Float

  id: Float
}

"""
order by avg() on columns of table "rendered_content"
"""
input rendered_content_avg_order_by {
  file_size_bytes: order_by

  id: order_by
}

"""
Boolean expression to filter rows from the table "rendered_content". All fields are combined with a logical 'AND'.
"""
input rendered_content_bool_exp {
  _and: [rendered_content_bool_exp!]

  _not: rendered_content_bool_exp

  _or: [rendered_content_bool_exp!]

  content: content_bool_exp

  content_id: String_comparison_exp

  created_at: timestamp_comparison_exp

  file_size_bytes: bigint_comparison_exp

  file_type: String_comparison_exp

  hash: String_comparison_exp

  id: Int_comparison_exp

  modified_on: timestamp_comparison_exp

  nonscripturalRenderingMetadataByRenderingId: nonscriptural_rendering_metadata_bool_exp

  nonscriptural_rendering_metadata: nonscriptural_rendering_metadata_bool_exp

  scriptural_rendering_metadata: scriptural_rendering_metadata_bool_exp

  url: String_comparison_exp
}

"""
aggregate max on columns
"""
type rendered_content_max_fields {
  content_id: String

  created_at: timestamp

  file_size_bytes: bigint

  file_type: String

  hash: String

  id: Int

  modified_on: timestamp

  url: String
}

"""
order by max() on columns of table "rendered_content"
"""
input rendered_content_max_order_by {
  content_id: order_by

  created_at: order_by

  file_size_bytes: order_by

  file_type: order_by

  hash: order_by

  id: order_by

  modified_on: order_by

  url: order_by
}

"""
aggregate min on columns
"""
type rendered_content_min_fields {
  content_id: String

  created_at: timestamp

  file_size_bytes: bigint

  file_type: String

  hash: String

  id: Int

  modified_on: timestamp

  url: String
}

"""
order by min() on columns of table "rendered_content"
"""
input rendered_content_min_order_by {
  content_id: order_by

  created_at: order_by

  file_size_bytes: order_by

  file_type: order_by

  hash: order_by

  id: order_by

  modified_on: order_by

  url: order_by
}

"""
Ordering options when selecting data from "rendered_content".
"""
input rendered_content_order_by {
  content: content_order_by

  content_id: order_by

  created_at: order_by

  file_size_bytes: order_by

  file_type: order_by

  hash: order_by

  id: order_by

  modified_on: order_by

  nonscripturalRenderingMetadataByRenderingId_aggregate: nonscriptural_rendering_metadata_aggregate_order_by

  nonscriptural_rendering_metadata: nonscriptural_rendering_metadata_order_by

  scriptural_rendering_metadata: scriptural_rendering_metadata_order_by

  url: order_by
}

"""
select columns of table "rendered_content"
"""
enum rendered_content_select_column {
  """
  column name
  """
  content_id

  """
  column name
  """
  created_at

  """
  column name
  """
  file_size_bytes

  """
  column name
  """
  file_type

  """
  column name
  """
  hash

  """
  column name
  """
  id

  """
  column name
  """
  modified_on

  """
  column name
  """
  url
}

"""
aggregate stddev on columns
"""
type rendered_content_stddev_fields {
  file_size_bytes: Float

  id: Float
}

"""
order by stddev() on columns of table "rendered_content"
"""
input rendered_content_stddev_order_by {
  file_size_bytes: order_by

  id: order_by
}

"""
aggregate stddev_pop on columns
"""
type rendered_content_stddev_pop_fields {
  file_size_bytes: Float

  id: Float
}

"""
order by stddev_pop() on columns of table "rendered_content"
"""
input rendered_content_stddev_pop_order_by {
  file_size_bytes: order_by

  id: order_by
}

"""
aggregate stddev_samp on columns
"""
type rendered_content_stddev_samp_fields {
  file_size_bytes: Float

  id: Float
}

"""
order by stddev_samp() on columns of table "rendered_content"
"""
input rendered_content_stddev_samp_order_by {
  file_size_bytes: order_by

  id: order_by
}

"""
Streaming cursor of the table "rendered_content"
"""
input rendered_content_stream_cursor_input {
  """
  Stream column input with initial value
  """
  initial_value: rendered_content_stream_cursor_value_input!

  """
  cursor ordering
  """
  ordering: cursor_ordering
}

"""
Initial value of the column from where the streaming should start
"""
input rendered_content_stream_cursor_value_input {
  content_id: String

  created_at: timestamp

  file_size_bytes: bigint

  file_type: String

  hash: String

  id: Int

  modified_on: timestamp

  url: String
}

"""
aggregate sum on columns
"""
type rendered_content_sum_fields {
  file_size_bytes: bigint

  id: Int
}

"""
order by sum() on columns of table "rendered_content"
"""
input rendered_content_sum_order_by {
  file_size_bytes: order_by

  id: order_by
}

"""
aggregate var_pop on columns
"""
type rendered_content_var_pop_fields {
  file_size_bytes: Float

  id: Float
}

"""
order by var_pop() on columns of table "rendered_content"
"""
input rendered_content_var_pop_order_by {
  file_size_bytes: order_by

  id: order_by
}

"""
aggregate var_samp on columns
"""
type rendered_content_var_samp_fields {
  file_size_bytes: Float

  id: Float
}

"""
order by var_samp() on columns of table "rendered_content"
"""
input rendered_content_var_samp_order_by {
  file_size_bytes: order_by

  id: order_by
}

"""
aggregate variance on columns
"""
type rendered_content_variance_fields {
  file_size_bytes: Float

  id: Float
}

"""
order by variance() on columns of table "rendered_content"
"""
input rendered_content_variance_order_by {
  file_size_bytes: order_by

  id: order_by
}

"""
columns and relationships of "scriptural_rendering_metadata"
"""
type scriptural_rendering_metadata {
  book_name: String

  book_slug: String

  chapter: Int

  id: Int!

  is_whole_book: Boolean!

  is_whole_project: Boolean!

  """
  An object relationship
  """
  rendered_content: rendered_content!

  rendering_id: Int!

  sort: smallint
}

"""
Boolean expression to filter rows from the table "scriptural_rendering_metadata". All fields are combined with a logical 'AND'.
"""
input scriptural_rendering_metadata_bool_exp {
  _and: [scriptural_rendering_metadata_bool_exp!]

  _not: scriptural_rendering_metadata_bool_exp

  _or: [scriptural_rendering_metadata_bool_exp!]

  book_name: String_comparison_exp

  book_slug: String_comparison_exp

  chapter: Int_comparison_exp

  id: Int_comparison_exp

  is_whole_book: Boolean_comparison_exp

  is_whole_project: Boolean_comparison_exp

  rendered_content: rendered_content_bool_exp

  rendering_id: Int_comparison_exp

  sort: smallint_comparison_exp
}

"""
Ordering options when selecting data from "scriptural_rendering_metadata".
"""
input scriptural_rendering_metadata_order_by {
  book_name: order_by

  book_slug: order_by

  chapter: order_by

  id: order_by

  is_whole_book: order_by

  is_whole_project: order_by

  rendered_content: rendered_content_order_by

  rendering_id: order_by

  sort: order_by
}

"""
select columns of table "scriptural_rendering_metadata"
"""
enum scriptural_rendering_metadata_select_column {
  """
  column name
  """
  book_name

  """
  column name
  """
  book_slug

  """
  column name
  """
  chapter

  """
  column name
  """
  id

  """
  column name
  """
  is_whole_book

  """
  column name
  """
  is_whole_project

  """
  column name
  """
  rendering_id

  """
  column name
  """
  sort
}

"""
Streaming cursor of the table "scriptural_rendering_metadata"
"""
input scriptural_rendering_metadata_stream_cursor_input {
  """
  Stream column input with initial value
  """
  initial_value: scriptural_rendering_metadata_stream_cursor_value_input!

  """
  cursor ordering
  """
  ordering: cursor_ordering
}

"""
Initial value of the column from where the streaming should start
"""
input scriptural_rendering_metadata_stream_cursor_value_input {
  book_name: String

  book_slug: String

  chapter: Int

  id: Int

  is_whole_book: Boolean

  is_whole_project: Boolean

  rendering_id: Int

  sort: smallint
}

scalar smallint

"""
Boolean expression to compare columns of type "smallint". All fields are combined with logical 'AND'.
"""
input smallint_comparison_exp {
  _eq: smallint

  _gt: smallint

  _gte: smallint

  _in: [smallint!]

  _is_null: Boolean

  _lt: smallint

  _lte: smallint

  _neq: smallint

  _nin: [smallint!]
}

"""
columns and relationships of "source_zips"
"""
type source_zips {
  created_on: timestamp

  domain: domain

  id: String

  ietf_code: String

  language_english_name: String

  language_name: String

  meta_status: String

  modified_on: timestamp

  name: String

  namespace: String

  repo_url: String

  resource_type: String

  show_on_biel: Boolean

  unique_book_slugs_count: bigint

  zip_url: String
}

"""
Boolean expression to filter rows from the table "source_zips". All fields are combined with a logical 'AND'.
"""
input source_zips_bool_exp {
  _and: [source_zips_bool_exp!]

  _not: source_zips_bool_exp

  _or: [source_zips_bool_exp!]

  created_on: timestamp_comparison_exp

  domain: domain_comparison_exp

  id: String_comparison_exp

  ietf_code: String_comparison_exp

  language_english_name: String_comparison_exp

  language_name: String_comparison_exp

  meta_status: String_comparison_exp

  modified_on: timestamp_comparison_exp

  name: String_comparison_exp

  namespace: String_comparison_exp

  repo_url: String_comparison_exp

  resource_type: String_comparison_exp

  show_on_biel: Boolean_comparison_exp

  unique_book_slugs_count: bigint_comparison_exp

  zip_url: String_comparison_exp
}

"""
Ordering options when selecting data from "source_zips".
"""
input source_zips_order_by {
  created_on: order_by

  domain: order_by

  id: order_by

  ietf_code: order_by

  language_english_name: order_by

  language_name: order_by

  meta_status: order_by

  modified_on: order_by

  name: order_by

  namespace: order_by

  repo_url: order_by

  resource_type: order_by

  show_on_biel: order_by

  unique_book_slugs_count: order_by

  zip_url: order_by
}

"""
select columns of table "source_zips"
"""
enum source_zips_select_column {
  """
  column name
  """
  created_on

  """
  column name
  """
  domain

  """
  column name
  """
  id

  """
  column name
  """
  ietf_code

  """
  column name
  """
  language_english_name

  """
  column name
  """
  language_name

  """
  column name
  """
  meta_status

  """
  column name
  """
  modified_on

  """
  column name
  """
  name

  """
  column name
  """
  namespace

  """
  column name
  """
  repo_url

  """
  column name
  """
  resource_type

  """
  column name
  """
  show_on_biel

  """
  column name
  """
  unique_book_slugs_count

  """
  column name
  """
  zip_url
}

"""
Streaming cursor of the table "source_zips"
"""
input source_zips_stream_cursor_input {
  """
  Stream column input with initial value
  """
  initial_value: source_zips_stream_cursor_value_input!

  """
  cursor ordering
  """
  ordering: cursor_ordering
}

"""
Initial value of the column from where the streaming should start
"""
input source_zips_stream_cursor_value_input {
  created_on: timestamp

  domain: domain

  id: String

  ietf_code: String

  language_english_name: String

  language_name: String

  meta_status: String

  modified_on: timestamp

  name: String

  namespace: String

  repo_url: String

  resource_type: String

  show_on_biel: Boolean

  unique_book_slugs_count: bigint

  zip_url: String
}

type subscription_root {
  """
  fetch data from the table: "content"
  """
  content("distinct select on columns" distinct_on: [content_select_column!], "limit the number of rows returned" limit: Int, "skip the first n rows. Use only with order_by" offset: Int, "sort the rows by one or more columns" order_by: [content_order_by!], "filter the rows returned" where: content_bool_exp): [content!]!

  """
  fetch aggregated fields from the table: "content"
  """
  content_aggregate("distinct select on columns" distinct_on: [content_select_column!], "limit the number of rows returned" limit: Int, "skip the first n rows. Use only with order_by" offset: Int, "sort the rows by one or more columns" order_by: [content_order_by!], "filter the rows returned" where: content_bool_exp): content_aggregate!

  """
  fetch data from the table: "content" using primary key columns
  """
  content_by_pk(id: String!): content

  """
  fetch data from the table in a streaming manner: "content"
  """
  content_stream("maximum number of rows returned in a single batch" batch_size: Int!, "cursor to stream the results returned by the query" cursor: [content_stream_cursor_input]!, "filter the rows returned" where: content_bool_exp): [content!]!

  """
  fetch data from the table: "country"
  """
  country("distinct select on columns" distinct_on: [country_select_column!], "limit the number of rows returned" limit: Int, "skip the first n rows. Use only with order_by" offset: Int, "sort the rows by one or more columns" order_by: [country_order_by!], "filter the rows returned" where: country_bool_exp): [country!]!

  """
  fetch aggregated fields from the table: "country"
  """
  country_aggregate("distinct select on columns" distinct_on: [country_select_column!], "limit the number of rows returned" limit: Int, "skip the first n rows. Use only with order_by" offset: Int, "sort the rows by one or more columns" order_by: [country_order_by!], "filter the rows returned" where: country_bool_exp): country_aggregate!

  """
  fetch data from the table: "country" using primary key columns
  """
  country_by_pk(id: Int!): country

  """
  fetch data from the table in a streaming manner: "country"
  """
  country_stream("maximum number of rows returned in a single batch" batch_size: Int!, "cursor to stream the results returned by the query" cursor: [country_stream_cursor_input]!, "filter the rows returned" where: country_bool_exp): [country!]!

  """
  fetch data from the table: "country_to_language"
  """
  country_to_language("distinct select on columns" distinct_on: [country_to_language_select_column!], "limit the number of rows returned" limit: Int, "skip the first n rows. Use only with order_by" offset: Int, "sort the rows by one or more columns" order_by: [country_to_language_order_by!], "filter the rows returned" where: country_to_language_bool_exp): [country_to_language!]!

  """
  fetch data from the table: "country_to_language" using primary key columns
  """
  country_to_language_by_pk(country_alpha_2: String!, language_ietf_code: String!): country_to_language

  """
  fetch data from the table in a streaming manner: "country_to_language"
  """
  country_to_language_stream("maximum number of rows returned in a single batch" batch_size: Int!, "cursor to stream the results returned by the query" cursor: [country_to_language_stream_cursor_input]!, "filter the rows returned" where: country_to_language_bool_exp): [country_to_language!]!

  """
  fetch data from the table: "gateway_language_to_dependent_language"
  """
  gateway_language_to_dependent_language("distinct select on columns" distinct_on: [gateway_language_to_dependent_language_select_column!], "limit the number of rows returned" limit: Int, "skip the first n rows. Use only with order_by" offset: Int, "sort the rows by one or more columns" order_by: [gateway_language_to_dependent_language_order_by!], "filter the rows returned" where: gateway_language_to_dependent_language_bool_exp): [gateway_language_to_dependent_language!]!

  """
  fetch aggregated fields from the table: "gateway_language_to_dependent_language"
  """
  gateway_language_to_dependent_language_aggregate("distinct select on columns" distinct_on: [gateway_language_to_dependent_language_select_column!], "limit the number of rows returned" limit: Int, "skip the first n rows. Use only with order_by" offset: Int, "sort the rows by one or more columns" order_by: [gateway_language_to_dependent_language_order_by!], "filter the rows returned" where: gateway_language_to_dependent_language_bool_exp): gateway_language_to_dependent_language_aggregate!

  """
  fetch data from the table: "gateway_language_to_dependent_language" using primary key columns
  """
  gateway_language_to_dependent_language_by_pk(dependent_language_ietf: String!, gateway_language_ietf: String!): gateway_language_to_dependent_language

  """
  fetch data from the table in a streaming manner: "gateway_language_to_dependent_language"
  """
  gateway_language_to_dependent_language_stream("maximum number of rows returned in a single batch" batch_size: Int!, "cursor to stream the results returned by the query" cursor: [gateway_language_to_dependent_language_stream_cursor_input]!, "filter the rows returned" where: gateway_language_to_dependent_language_bool_exp): [gateway_language_to_dependent_language!]!

  """
  fetch data from the table: "git_repo"
  """
  git_repo("distinct select on columns" distinct_on: [git_repo_select_column!], "limit the number of rows returned" limit: Int, "skip the first n rows. Use only with order_by" offset: Int, "sort the rows by one or more columns" order_by: [git_repo_order_by!], "filter the rows returned" where: git_repo_bool_exp): [git_repo!]!

  """
  fetch data from the table: "git_repo" using primary key columns
  """
  git_repo_by_pk(id: Int!): git_repo

  """
  fetch data from the table in a streaming manner: "git_repo"
  """
  git_repo_stream("maximum number of rows returned in a single batch" batch_size: Int!, "cursor to stream the results returned by the query" cursor: [git_repo_stream_cursor_input]!, "filter the rows returned" where: git_repo_bool_exp): [git_repo!]!

  """
  fetch data from the table: "language"
  """
  language("distinct select on columns" distinct_on: [language_select_column!], "limit the number of rows returned" limit: Int, "skip the first n rows. Use only with order_by" offset: Int, "sort the rows by one or more columns" order_by: [language_order_by!], "filter the rows returned" where: language_bool_exp): [language!]!

  """
  fetch aggregated fields from the table: "language"
  """
  language_aggregate("distinct select on columns" distinct_on: [language_select_column!], "limit the number of rows returned" limit: Int, "skip the first n rows. Use only with order_by" offset: Int, "sort the rows by one or more columns" order_by: [language_order_by!], "filter the rows returned" where: language_bool_exp): language_aggregate!

  """
  fetch data from the table: "language_alternate_name"
  """
  language_alternate_name("distinct select on columns" distinct_on: [language_alternate_name_select_column!], "limit the number of rows returned" limit: Int, "skip the first n rows. Use only with order_by" offset: Int, "sort the rows by one or more columns" order_by: [language_alternate_name_order_by!], "filter the rows returned" where: language_alternate_name_bool_exp): [language_alternate_name!]!

  """
  fetch aggregated fields from the table: "language_alternate_name"
  """
  language_alternate_name_aggregate("distinct select on columns" distinct_on: [language_alternate_name_select_column!], "limit the number of rows returned" limit: Int, "skip the first n rows. Use only with order_by" offset: Int, "sort the rows by one or more columns" order_by: [language_alternate_name_order_by!], "filter the rows returned" where: language_alternate_name_bool_exp): language_alternate_name_aggregate!

  """
  fetch data from the table: "language_alternate_name" using primary key columns
  """
  language_alternate_name_by_pk(id: Int!): language_alternate_name

  """
  fetch data from the table in a streaming manner: "language_alternate_name"
  """
  language_alternate_name_stream("maximum number of rows returned in a single batch" batch_size: Int!, "cursor to stream the results returned by the query" cursor: [language_alternate_name_stream_cursor_input]!, "filter the rows returned" where: language_alternate_name_bool_exp): [language_alternate_name!]!

  """
  fetch data from the table: "language" using primary key columns
  """
  language_by_pk(ietf_code: String!): language

  """
  fetch data from the table in a streaming manner: "language"
  """
  language_stream("maximum number of rows returned in a single batch" batch_size: Int!, "cursor to stream the results returned by the query" cursor: [language_stream_cursor_input]!, "filter the rows returned" where: language_bool_exp): [language!]!

  """
  fetch data from the table: "localization"
  """
  localization("distinct select on columns" distinct_on: [localization_select_column!], "limit the number of rows returned" limit: Int, "skip the first n rows. Use only with order_by" offset: Int, "sort the rows by one or more columns" order_by: [localization_order_by!], "filter the rows returned" where: localization_bool_exp): [localization!]!

  """
  fetch data from the table: "localization" using primary key columns
  """
  localization_by_pk(category: String!, ietf_code: String!, key: String!): localization

  """
  fetch data from the table in a streaming manner: "localization"
  """
  localization_stream("maximum number of rows returned in a single batch" batch_size: Int!, "cursor to stream the results returned by the query" cursor: [localization_stream_cursor_input]!, "filter the rows returned" where: localization_bool_exp): [localization!]!

  """
  fetch data from the table: "nonscriptural_rendering_metadata"
  """
  nonscriptural_rendering_metadata("distinct select on columns" distinct_on: [nonscriptural_rendering_metadata_select_column!], "limit the number of rows returned" limit: Int, "skip the first n rows. Use only with order_by" offset: Int, "sort the rows by one or more columns" order_by: [nonscriptural_rendering_metadata_order_by!], "filter the rows returned" where: nonscriptural_rendering_metadata_bool_exp): [nonscriptural_rendering_metadata!]!

  """
  fetch data from the table: "nonscriptural_rendering_metadata" using primary key columns
  """
  nonscriptural_rendering_metadata_by_pk(id: Int!): nonscriptural_rendering_metadata

  """
  fetch data from the table in a streaming manner: "nonscriptural_rendering_metadata"
  """
  nonscriptural_rendering_metadata_stream("maximum number of rows returned in a single batch" batch_size: Int!, "cursor to stream the results returned by the query" cursor: [nonscriptural_rendering_metadata_stream_cursor_input]!, "filter the rows returned" where: nonscriptural_rendering_metadata_bool_exp): [nonscriptural_rendering_metadata!]!

  """
  fetch data from the table: "rendered_content"
  """
  rendered_content("distinct select on columns" distinct_on: [rendered_content_select_column!], "limit the number of rows returned" limit: Int, "skip the first n rows. Use only with order_by" offset: Int, "sort the rows by one or more columns" order_by: [rendered_content_order_by!], "filter the rows returned" where: rendered_content_bool_exp): [rendered_content!]!

  """
  fetch aggregated fields from the table: "rendered_content"
  """
  rendered_content_aggregate("distinct select on columns" distinct_on: [rendered_content_select_column!], "limit the number of rows returned" limit: Int, "skip the first n rows. Use only with order_by" offset: Int, "sort the rows by one or more columns" order_by: [rendered_content_order_by!], "filter the rows returned" where: rendered_content_bool_exp): rendered_content_aggregate!

  """
  fetch data from the table: "rendered_content" using primary key columns
  """
  rendered_content_by_pk(id: Int!): rendered_content

  """
  fetch data from the table in a streaming manner: "rendered_content"
  """
  rendered_content_stream("maximum number of rows returned in a single batch" batch_size: Int!, "cursor to stream the results returned by the query" cursor: [rendered_content_stream_cursor_input]!, "filter the rows returned" where: rendered_content_bool_exp): [rendered_content!]!

  """
  fetch data from the table: "scriptural_rendering_metadata"
  """
  scriptural_rendering_metadata("distinct select on columns" distinct_on: [scriptural_rendering_metadata_select_column!], "limit the number of rows returned" limit: Int, "skip the first n rows. Use only with order_by" offset: Int, "sort the rows by one or more columns" order_by: [scriptural_rendering_metadata_order_by!], "filter the rows returned" where: scriptural_rendering_metadata_bool_exp): [scriptural_rendering_metadata!]!

  """
  fetch data from the table: "scriptural_rendering_metadata" using primary key columns
  """
  scriptural_rendering_metadata_by_pk(id: Int!): scriptural_rendering_metadata

  """
  fetch data from the table in a streaming manner: "scriptural_rendering_metadata"
  """
  scriptural_rendering_metadata_stream("maximum number of rows returned in a single batch" batch_size: Int!, "cursor to stream the results returned by the query" cursor: [scriptural_rendering_metadata_stream_cursor_input]!, "filter the rows returned" where: scriptural_rendering_metadata_bool_exp): [scriptural_rendering_metadata!]!

  """
  fetch data from the table: "source_zips"
  """
  source_zips("distinct select on columns" distinct_on: [source_zips_select_column!], "limit the number of rows returned" limit: Int, "skip the first n rows. Use only with order_by" offset: Int, "sort the rows by one or more columns" order_by: [source_zips_order_by!], "filter the rows returned" where: source_zips_bool_exp): [source_zips!]!

  """
  fetch data from the table in a streaming manner: "source_zips"
  """
  source_zips_stream("maximum number of rows returned in a single batch" batch_size: Int!, "cursor to stream the results returned by the query" cursor: [source_zips_stream_cursor_input]!, "filter the rows returned" where: source_zips_bool_exp): [source_zips!]!

  """
  fetch data from the table: "vw_langnames"
  """
  vw_langnames("distinct select on columns" distinct_on: [vw_langnames_select_column!], "limit the number of rows returned" limit: Int, "skip the first n rows. Use only with order_by" offset: Int, "sort the rows by one or more columns" order_by: [vw_langnames_order_by!], "filter the rows returned" where: vw_langnames_bool_exp): [vw_langnames!]!

  """
  fetch data from the table in a streaming manner: "vw_langnames"
  """
  vw_langnames_stream("maximum number of rows returned in a single batch" batch_size: Int!, "cursor to stream the results returned by the query" cursor: [vw_langnames_stream_cursor_input]!, "filter the rows returned" where: vw_langnames_bool_exp): [vw_langnames!]!

  """
  fetch data from the table: "wa_content_metadata"
  """
  wa_content_metadata("distinct select on columns" distinct_on: [wa_content_metadata_select_column!], "limit the number of rows returned" limit: Int, "skip the first n rows. Use only with order_by" offset: Int, "sort the rows by one or more columns" order_by: [wa_content_metadata_order_by!], "filter the rows returned" where: wa_content_metadata_bool_exp): [wa_content_metadata!]!

  """
  fetch data from the table: "wa_content_metadata" using primary key columns
  """
  wa_content_metadata_by_pk(id: Int!): wa_content_metadata

  """
  fetch data from the table in a streaming manner: "wa_content_metadata"
  """
  wa_content_metadata_stream("maximum number of rows returned in a single batch" batch_size: Int!, "cursor to stream the results returned by the query" cursor: [wa_content_metadata_stream_cursor_input]!, "filter the rows returned" where: wa_content_metadata_bool_exp): [wa_content_metadata!]!

  """
  fetch data from the table: "wa_language_metadata"
  """
  wa_language_metadata("distinct select on columns" distinct_on: [wa_language_metadata_select_column!], "limit the number of rows returned" limit: Int, "skip the first n rows. Use only with order_by" offset: Int, "sort the rows by one or more columns" order_by: [wa_language_metadata_order_by!], "filter the rows returned" where: wa_language_metadata_bool_exp): [wa_language_metadata!]!

  """
  fetch data from the table: "wa_language_metadata" using primary key columns
  """
  wa_language_metadata_by_pk(id: Int!): wa_language_metadata

  """
  fetch data from the table in a streaming manner: "wa_language_metadata"
  """
  wa_language_metadata_stream("maximum number of rows returned in a single batch" batch_size: Int!, "cursor to stream the results returned by the query" cursor: [wa_language_metadata_stream_cursor_input]!, "filter the rows returned" where: wa_language_metadata_bool_exp): [wa_language_metadata!]!

  """
  fetch data from the table: "world_region"
  """
  world_region("distinct select on columns" distinct_on: [world_region_select_column!], "limit the number of rows returned" limit: Int, "skip the first n rows. Use only with order_by" offset: Int, "sort the rows by one or more columns" order_by: [world_region_order_by!], "filter the rows returned" where: world_region_bool_exp): [world_region!]!

  """
  fetch data from the table: "world_region" using primary key columns
  """
  world_region_by_pk(id: Int!): world_region

  """
  fetch data from the table in a streaming manner: "world_region"
  """
  world_region_stream("maximum number of rows returned in a single batch" batch_size: Int!, "cursor to stream the results returned by the query" cursor: [world_region_stream_cursor_input]!, "filter the rows returned" where: world_region_bool_exp): [world_region!]!
}

scalar timestamp

"""
Boolean expression to compare columns of type "timestamp". All fields are combined with logical 'AND'.
"""
input timestamp_comparison_exp {
  _eq: timestamp

  _gt: timestamp

  _gte: timestamp

  _in: [timestamp!]

  _is_null: Boolean

  _lt: timestamp

  _lte: timestamp

  _neq: timestamp

  _nin: [timestamp!]
}

scalar type_id

"""
Boolean expression to compare columns of type "type_id". All fields are combined with logical 'AND'.
"""
input type_id_comparison_exp {
  _eq: type_id

  _gt: type_id

  _gte: type_id

  _in: [type_id!]

  _is_null: Boolean

  _lt: type_id

  _lte: type_id

  _neq: type_id

  _nin: [type_id!]
}

"""
columns and relationships of "vw_langnames"
"""
type vw_langnames {
  alt: [String!]

  ang: String

  cc: [String!]

  gw: Boolean

  hc: String

  lc: String

  ld: direction

  ln: String

  lr: String

  pk: Int
}

"""
Boolean expression to filter rows from the table "vw_langnames". All fields are combined with a logical 'AND'.
"""
input vw_langnames_bool_exp {
  _and: [vw_langnames_bool_exp!]

  _not: vw_langnames_bool_exp

  _or: [vw_langnames_bool_exp!]

  alt: String_array_comparison_exp

  ang: String_comparison_exp

  cc: String_array_comparison_exp

  gw: Boolean_comparison_exp

  hc: String_comparison_exp

  lc: String_comparison_exp

  ld: direction_comparison_exp

  ln: String_comparison_exp

  lr: String_comparison_exp

  pk: Int_comparison_exp
}

"""
Ordering options when selecting data from "vw_langnames".
"""
input vw_langnames_order_by {
  alt: order_by

  ang: order_by

  cc: order_by

  gw: order_by

  hc: order_by

  lc: order_by

  ld: order_by

  ln: order_by

  lr: order_by

  pk: order_by
}

"""
select columns of table "vw_langnames"
"""
enum vw_langnames_select_column {
  """
  column name
  """
  alt

  """
  column name
  """
  ang

  """
  column name
  """
  cc

  """
  column name
  """
  gw

  """
  column name
  """
  hc

  """
  column name
  """
  lc

  """
  column name
  """
  ld

  """
  column name
  """
  ln

  """
  column name
  """
  lr

  """
  column name
  """
  pk
}

"""
Streaming cursor of the table "vw_langnames"
"""
input vw_langnames_stream_cursor_input {
  """
  Stream column input with initial value
  """
  initial_value: vw_langnames_stream_cursor_value_input!

  """
  cursor ordering
  """
  ordering: cursor_ordering
}

"""
Initial value of the column from where the streaming should start
"""
input vw_langnames_stream_cursor_value_input {
  alt: [String!]

  ang: String

  cc: [String!]

  gw: Boolean

  hc: String

  lc: String

  ld: direction

  ln: String

  lr: String

  pk: Int
}

"""
columns and relationships of "wa_content_metadata"
"""
type wa_content_metadata {
  """
  An object relationship
  """
  content: content!

  content_id: String!

  id: Int!

  show_on_biel: Boolean!

  status: String!
}

"""
Boolean expression to filter rows from the table "wa_content_metadata". All fields are combined with a logical 'AND'.
"""
input wa_content_metadata_bool_exp {
  _and: [wa_content_metadata_bool_exp!]

  _not: wa_content_metadata_bool_exp

  _or: [wa_content_metadata_bool_exp!]

  content: content_bool_exp

  content_id: String_comparison_exp

  id: Int_comparison_exp

  show_on_biel: Boolean_comparison_exp

  status: String_comparison_exp
}

"""
Ordering options when selecting data from "wa_content_metadata".
"""
input wa_content_metadata_order_by {
  content: content_order_by

  content_id: order_by

  id: order_by

  show_on_biel: order_by

  status: order_by
}

"""
select columns of table "wa_content_metadata"
"""
enum wa_content_metadata_select_column {
  """
  column name
  """
  content_id

  """
  column name
  """
  id

  """
  column name
  """
  show_on_biel

  """
  column name
  """
  status
}

"""
Streaming cursor of the table "wa_content_metadata"
"""
input wa_content_metadata_stream_cursor_input {
  """
  Stream column input with initial value
  """
  initial_value: wa_content_metadata_stream_cursor_value_input!

  """
  cursor ordering
  """
  ordering: cursor_ordering
}

"""
Initial value of the column from where the streaming should start
"""
input wa_content_metadata_stream_cursor_value_input {
  content_id: String

  id: Int

  show_on_biel: Boolean

  status: String
}

"""
columns and relationships of "wa_language_metadata"
"""
type wa_language_metadata {
  id: Int!

  ietf_code: String!

  is_gateway: Boolean!

  """
  An object relationship
  """
  language: language!

  show_on_biel: Boolean!
}

"""
Boolean expression to filter rows from the table "wa_language_metadata". All fields are combined with a logical 'AND'.
"""
input wa_language_metadata_bool_exp {
  _and: [wa_language_metadata_bool_exp!]

  _not: wa_language_metadata_bool_exp

  _or: [wa_language_metadata_bool_exp!]

  id: Int_comparison_exp

  ietf_code: String_comparison_exp

  is_gateway: Boolean_comparison_exp

  language: language_bool_exp

  show_on_biel: Boolean_comparison_exp
}

"""
Ordering options when selecting data from "wa_language_metadata".
"""
input wa_language_metadata_order_by {
  id: order_by

  ietf_code: order_by

  is_gateway: order_by

  language: language_order_by

  show_on_biel: order_by
}

"""
select columns of table "wa_language_metadata"
"""
enum wa_language_metadata_select_column {
  """
  column name
  """
  id

  """
  column name
  """
  ietf_code

  """
  column name
  """
  is_gateway

  """
  column name
  """
  show_on_biel
}

"""
Streaming cursor of the table "wa_language_metadata"
"""
input wa_language_metadata_stream_cursor_input {
  """
  Stream column input with initial value
  """
  initial_value: wa_language_metadata_stream_cursor_value_input!

  """
  cursor ordering
  """
  ordering: cursor_ordering
}

"""
Initial value of the column from where the streaming should start
"""
input wa_language_metadata_stream_cursor_value_input {
  id: Int

  ietf_code: String

  is_gateway: Boolean

  show_on_biel: Boolean
}

"""
columns and relationships of "world_region"
"""
type world_region {
  """
  An array relationship
  """
  countries("distinct select on columns" distinct_on: [country_select_column!], "limit the number of rows returned" limit: Int, "skip the first n rows. Use only with order_by" offset: Int, "sort the rows by one or more columns" order_by: [country_order_by!], "filter the rows returned" where: country_bool_exp): [country!]!

  """
  An aggregate relationship
  """
  countries_aggregate("distinct select on columns" distinct_on: [country_select_column!], "limit the number of rows returned" limit: Int, "skip the first n rows. Use only with order_by" offset: Int, "sort the rows by one or more columns" order_by: [country_order_by!], "filter the rows returned" where: country_bool_exp): country_aggregate!

  created_on: timestamp

  id: Int!

  modified_on: timestamp

  region: String!
}

"""
Boolean expression to filter rows from the table "world_region". All fields are combined with a logical 'AND'.
"""
input world_region_bool_exp {
  _and: [world_region_bool_exp!]

  _not: world_region_bool_exp

  _or: [world_region_bool_exp!]

  countries: country_bool_exp

  countries_aggregate: country_aggregate_bool_exp

  created_on: timestamp_comparison_exp

  id: Int_comparison_exp

  modified_on: timestamp_comparison_exp

  region: String_comparison_exp
}

"""
Ordering options when selecting data from "world_region".
"""
input world_region_order_by {
  countries_aggregate: country_aggregate_order_by

  created_on: order_by

  id: order_by

  modified_on: order_by

  region: order_by
}

"""
select columns of table "world_region"
"""
enum world_region_select_column {
  """
  column name
  """
  created_on

  """
  column name
  """
  id

  """
  column name
  """
  modified_on

  """
  column name
  """
  region
}

"""
Streaming cursor of the table "world_region"
"""
input world_region_stream_cursor_input {
  """
  Stream column input with initial value
  """
  initial_value: world_region_stream_cursor_value_input!

  """
  cursor ordering
  """
  ordering: cursor_ordering
}

"""
Initial value of the column from where the streaming should start
"""
input world_region_stream_cursor_value_input {
  created_on: timestamp

  id: Int

  modified_on: timestamp

  region: String
}

"""
whether this query should be included
"""
directive @include (if: Boolean!) on FIELD|FRAGMENT_SPREAD|INLINE_FRAGMENT

"""
whether this query should be skipped
"""
directive @skip (if: Boolean!) on FIELD|FRAGMENT_SPREAD|INLINE_FRAGMENT

"""
whether this query should be cached (Hasura Cloud only)
"""
directive @cached ("measured in seconds" ttl: Int! = 60, "refresh the cache entry" refresh: Boolean! = false) on QUERY

schema {
  query: query_root
  subscription: subscription_root
}
